# Decimo v0.8.0 Benchmark Report

**Date:** 2026-02-21 – 2026-02-25  
**System:** macOS (Darwin 25.3.0), ARM (Apple Silicon)  
**Python:** 3.13.5  
**Mojo:** 0.26.1  

Speedup = Python time ÷ Mojo time (>1× means Mojo is faster, <1× means Python is faster).

---

## PART I: BInt vs Python `int`

All benchmarks compare **BInt** (Decimo's binary-storage BigInt) against **Python's built-in `int`** (arbitrary precision). Times are in nanoseconds per iteration.

### 1. Addition

**Cases:** 24 | **Iterations:** 500 | **Average Speedup: 5.04×**

| Operand Size                 | BInt (ns/iter) | Python (ns/iter) | Speedup |
| ---------------------------- | -------------: | ---------------: | ------: |
| Small (1–2 digits)           |             46 |              302 |   6.57× |
| 10 digits                    |             48 |              290 |   6.04× |
| 50 digits                    |             46 |              310 |   6.74× |
| 100 digits                   |             46 |              284 |   6.17× |
| 500 digits                   |             66 |              288 |   4.36× |
| 1,000 digits (~104 words)    |             98 |              308 |   3.14× |
| 5,000 digits (~520 words)    |            492 |              748 |   1.52× |
| 10,000 digits (~1,041 words) |            760 |            1,150 |   1.51× |

> BInt addition dominates at all sizes, with 3–6× speedup for numbers up to 1,000 digits and still 1.5× at 10,000 digits.

---

### 2. Multiplication

**Cases:** 64 | **Iterations:** 100 | **Average Speedup: 4.72×**

| Operand Size                | BInt (ns/iter) | Python (ns/iter) | Speedup |
| --------------------------- | -------------: | ---------------: | ------: |
| Small (3-digit × 3-digit)   |             70 |              340 |   4.86× |
| 9-digit × 9-digit           |             60 |              360 |   6.00× |
| 50-digit × 50-digit         |            100 |              420 |   4.20× |
| 100-digit × 100-digit       |            150 |              420 |   2.80× |
| 200-digit × 200-digit       |            270 |              520 |   1.93× |
| 500-digit × 500-digit       |          1,410 |            2,000 |   1.42× |
| 1,000-digit × 1,000-digit   |          4,560 |            6,000 |   1.32× |
| 2,000-digit × 2,000-digit   |         16,780 |           17,340 |   1.03× |
| 5,000-digit × 5,000-digit   |         64,890 |           86,420 |   1.33× |
| 10,000-digit × 10,000-digit |        195,600 |          260,120 |   1.33× |

> BInt multiplication is faster across all tested sizes. Small operands see 5–6× speedup; 1,000+ digits still maintain a 1.3× advantage.

---

### 3. Floor Division

**Cases:** 62 | **Iterations:** 100 | **Average Speedup: 1.19×**

| Operand Size (dividend / divisor) | BInt (ns/iter) | Python (ns/iter) | Speedup |
| --------------------------------- | -------------: | ---------------: | ------: |
| Small (100 / 10)                  |            300 |              380 |   1.27× |
| 10-digit / 3-digit                |            260 |              370 |   1.42× |
| 50-digit / 7-digit                |            310 |              380 |   1.23× |
| 100-digit / 1-digit               |            290 |              310 |   1.07× |
| 300-digit / 200-digit             |            660 |              850 |   1.29× |
| 500-digit / 200-digit             |          1,080 |            1,790 |   1.66× |
| 1,000-digit / 300-digit           |          2,750 |            3,750 |   1.36× |
| 1,500-digit / 500-digit           |          5,470 |            7,300 |   1.33× |
| 5,000-digit / 2,500-digit         |         40,760 |           76,720 |   1.88× |
| 10,000-digit / 5,000-digit        |        128,620 |          181,090 |   1.41× |

> Floor division is competitive, with BInt ahead by 1.2–1.9× at most sizes. **Note:** when the result is negative (floor ≠ truncate), the extra adjustment can slightly reduce the speedup to ~0.8–0.9×.

---

### 4. Truncate Division

**Cases:** 23 | **Iterations:** 100 | **Average Speedup: 1.57×**

| Operand Size (dividend / divisor) | BInt (ns/iter) | Python (ns/iter) | Speedup |
| --------------------------------- | -------------: | ---------------: | ------: |
| Small (100 / 10)                  |            240 |              340 |   1.42× |
| 10-digit / 3-digit                |            190 |              270 |   1.42× |
| 50-digit / 7-digit                |            200 |              310 |   1.55× |
| 50-digit / 48-digit               |            270 |              370 |   1.37× |
| 100-digit / 1-digit               |            210 |              270 |   1.29× |
| 1,000-digit / 500-digit           |          2,530 |            3,620 |   1.43× |
| 5,000-digit / 2,500-digit         |         41,000 |           75,180 |   1.83× |
| 10,000-digit / 5,000-digit        |        127,900 |          193,200 |   1.51× |

> Truncate division is consistently faster than Python, typically 1.3–1.9×.

---

### 5. Square Root (isqrt)

**Cases:** 16 | **Iterations:** 50 | **Average Speedup: 1.85×**

| Input Size                   | BInt (ns/iter) | Python (ns/iter) | Speedup |
| ---------------------------- | -------------: | ---------------: | ------: |
| Small (100)                  |            180 |              700 |   3.89× |
| 10,000                       |            180 |              640 |   3.56× |
| 20 digits                    |            480 |              920 |   1.92× |
| 50 digits                    |            520 |            1,120 |   2.15× |
| 100 digits                   |          1,200 |            1,380 |   1.15× |
| 200 digits                   |          2,460 |            2,460 |   1.00× |
| 500 digits                   |          4,820 |            4,220 |   0.88× |
| 1,000 digits                 |          8,340 |            7,620 |   0.91× |
| 2,000 digits (~208 words)    |         16,640 |           18,380 |   1.10× |
| 5,000 digits (~520 words)    |         54,260 |           75,080 |   1.38× |
| 10,000 digits (~1,041 words) |        164,320 |          262,260 |   1.60× |

> BInt sqrt is 2–4× faster for small inputs. In the 200–1,000 digit range it's roughly on par with Python. At 2,000+ digits BInt pulls ahead again (1.4–1.6×).

---

### 6. Power (Exponentiation)

**Cases:** 21 | **Iterations:** 50 | **Average Speedup: 12.17×**

| Expression | Result Digits | BInt (ns/iter) | Python (ns/iter) |     Speedup |
| ---------- | ------------: | -------------: | ---------------: | ----------: |
| 2^10       |             4 |            100 |              320 |       3.20× |
| 2^64       |            20 |            120 |              420 |       3.50× |
| 2^256      |            78 |            100 |              400 |       4.00× |
| 2^1024     |           309 |            100 |              580 |       5.80× |
| 2^2048     |           617 |             80 |              820 |      10.25× |
| 2^8192     |         2,467 |            140 |            8,860 |  **63.29×** |
| 2^32768    |         9,865 |            320 |           48,020 | **150.06×** |
| 10^100     |           101 |            720 |              400 |       0.56× |
| 10^500     |           501 |          1,200 |              740 |       0.62× |
| 10^2000    |         2,001 |          7,440 |            5,900 |       0.79× |
| 99^50      |           100 |            640 |              520 |       0.81× |
| 99^500     |           998 |          3,020 |            1,580 |       0.52× |
| 99^2500    |         4,990 |         43,340 |           29,540 |       0.68× |

> **Power-of-2 exponentiation** is BInt's strongest area: the binary representation allows simple bit shifting, yielding 10–150× speedups for large exponents. For **non-power-of-2 bases**, BInt is 0.5–0.8× (slower) because the repeated multiplication incurs binary-to-decimal conversion overhead internally.

---

### 7. Left Shift

**Cases:** 17 | **Iterations:** 500 | **Average Speedup: 4.75×**

| Expression                   | BInt (ns/iter) | Python (ns/iter) | Speedup |
| ---------------------------- | -------------: | ---------------: | ------: |
| 1 << 1                       |             54 |              362 |   6.70× |
| 1 << 64                      |             48 |              300 |   6.25× |
| 1 << 256                     |             48 |              306 |   6.38× |
| 1 << 1024                    |             50 |              302 |   6.04× |
| 50-digit << 64               |             56 |              300 |   5.36× |
| 100-digit << 100             |             58 |              306 |   5.28× |
| 200-digit << 256             |             60 |              300 |   5.00× |
| 1,000-digit << 1000          |            112 |              360 |   3.21× |
| 5,000-digit << 5000          |            306 |              530 |   1.73× |
| 10,000-digit << 10000        |            672 |            1,064 |   1.58× |
| 1 << 100000 (~30,103 digits) |            796 |              384 |   0.48× |

> BInt shift is 5–7× faster for small-to-medium operands and maintains a 1.5× edge up to 10,000 digits. For extremely large shifts producing 30,000+ digit results, Python is faster due to its optimized memory allocation.

---

### 8. String → BInt (`from_string`)

**Cases:** 14 | **Iterations:** 50 | **Average Speedup: 1.76×**

| Input Digits          | BInt (ns/iter) | Python (ns/iter) | Speedup |
| --------------------- | -------------: | ---------------: | ------: |
| 2                     |            100 |              420 |   4.20× |
| 9                     |            120 |              340 |   2.83× |
| 20                    |            120 |              420 |   3.50× |
| 50                    |            220 |              460 |   2.09× |
| 100                   |            320 |              540 |   1.69× |
| 200                   |            560 |              780 |   1.39× |
| 500                   |          1,360 |            1,460 |   1.07× |
| 1,000                 |          4,380 |            4,900 |   1.12× |
| 2,000                 |         14,180 |           15,540 |   1.10× |
| 5,000                 |         70,340 |           80,680 |   1.15× |
| 10,000 (~1,041 words) |        275,100 |          230,800 |   0.84× |

> BInt parsing is 2–4× faster for numbers under 100 digits and stays competitive up to 5,000 digits. At 10,000 digits, Python's optimized C-level parsing pulls slightly ahead.

---

### 9. BInt → String (`to_string`)

**Cases:** 12 | **Iterations:** 200 | **Average Speedup: 6.24×**

| Output Digits         | BInt (ns/iter) | Python (ns/iter) | Speedup |
| --------------------- | -------------: | ---------------: | ------: |
| 2                     |             15 |              330 |  22.00× |
| 9                     |             10 |              320 |  32.00× |
| 20                    |             25 |              330 |  13.20× |
| 50                    |            345 |              360 |   1.04× |
| 100                   |            525 |              425 |   0.81× |
| 200                   |          1,000 |              705 |   0.71× |
| 500                   |          3,615 |            2,020 |   0.56× |
| 1,000                 |         14,320 |            7,560 |   0.53× |
| 2,000                 |         33,365 |           31,125 |   0.93× |
| 5,000                 |        148,675 |          205,620 |   1.38× |
| 10,000 (~1,041 words) |        467,075 |          523,810 |   1.12× |

> Small number stringification is 13–32× faster. For 100–2,000 digits, BInt's binary-to-decimal conversion is slower (0.5–0.9×). At 5,000+ digits BInt recovers to 1.1–1.4× as its divide-and-conquer approach scales better.

---

### PART I Summary

| Operation         | Average Speedup | Best Range                  | Peak Speedup |
| ----------------- | --------------: | --------------------------- | -----------: |
| Addition          |           5.04× | Small–medium numbers        |        6.74× |
| Multiplication    |           4.72× | Small–medium numbers        |       13.20× |
| Floor Division    |           1.19× | Large (5,000d / 2,500d)     |        1.88× |
| Truncate Division |           1.57× | Large (5,000d / 2,500d)     |        1.83× |
| Square Root       |           1.85× | Small & very large          |        3.89× |
| Power             |          12.17× | Power-of-2 bases            |      150.06× |
| Left Shift        |           4.75× | Small–medium numbers        |        8.25× |
| from_string       |           1.76× | Small numbers (<100 digits) |        4.20× |
| to_string         |           6.24× | Small numbers (<20 digits)  |       32.00× |

---

## PART II: BigDecimal (Decimal) vs Python `decimal.Decimal`

All benchmarks compare **BigDecimal** (Decimo's arbitrary-precision decimal type, alias `Decimal`) against **Python's `decimal.Decimal`** module. Both use **precision = 28** by default (same as Python's default). Only operations available in Python's standard `decimal` module are compared; trigonometric functions (sin, cos, arctan) and pi computation are excluded.

### 1. Addition (`Decimal`)

**Cases:** 60 | **Iterations:** 1,000 | **Average Speedup: 2.22×** | **Log date:** 2026-02-20

| Category                       | BigDecimal (ns) | Python (ns) | Speedup |
| ------------------------------ | --------------: | ----------: | ------: |
| Simple integer (7 + 6)         |              80 |         256 |   3.20× |
| Simple decimal (3.5 + 2.5)     |              74 |         232 |   3.14× |
| Different scales (1.5 + 0.25)  |              72 |         230 |   3.19× |
| Add with zero                  |              37 |         234 |   6.34× |
| Negative + positive            |              83 |         254 |   3.06× |
| Negative + negative            |              78 |         242 |   3.10× |
| Precision limit (28-digit)     |              88 |         258 |   2.93× |
| Repeating pattern              |              84 |         258 |   3.07× |
| Large integer (28-digit)       |              92 |         242 |   2.63× |
| Scientific notation            |              76 |         258 |   3.39× |
| Financial (10542.75 + 3621.50) |              76 |         252 |   3.32× |
| 1,000-digit decimal            |             170 |         260 |   1.53× |
| 1,500-digit decimal            |             174 |         284 |   1.63× |
| 2,000-digit decimal            |             188 |         254 |   1.35× |
| 2,500-digit decimal            |             290 |         242 |   0.83× |
| 3,000-digit decimal            |             324 |         244 |   0.75× |

> BigDecimal addition is 2.5–6× faster for standard-precision decimals. At 1,000–2,000 digits it's still ~1.5× faster. Beyond ~2,500 digits, Python's C-optimized `decimal` catches up.

---

### 2. Subtraction (`Decimal`)

**Cases:** 50 | **Iterations:** 1,000 | **Average Speedup: 9.79×** | **Log date:** 2025-07-01

| Category                          | BigDecimal (ns) | Python (ns) | Speedup |
| --------------------------------- | --------------: | ----------: | ------: |
| Simple integer (100 - 42)         |             195 |       1,701 |   8.73× |
| Simple decimal (10.5 - 2.5)       |             223 |       1,697 |   7.61× |
| Different scales (10.2345 - 5.67) |             168 |       1,698 |  10.11× |
| Subtract zero                     |              59 |       1,698 |  28.78× |
| Precision limit (28-digit)        |             201 |       1,694 |   8.43× |
| High precision repeating pattern  |             158 |       1,769 |  11.20× |
| Resulting in exact 0.0            |             141 |       1,585 |  11.24× |
| Negative − positive               |             170 |       1,599 |   9.41× |
| Negative − negative               |             168 |       1,801 |  10.72× |
| Large integer subtraction         |             193 |       1,499 |   7.77× |
| Scientific measurement (physics)  |             161 |       1,391 |   8.64× |
| Financial (market price changes)  |             158 |       1,447 |   9.16× |
| Mathematical constants (PI − E)   |             189 |       1,617 |   8.56× |
| GPS coordinates                   |             159 |       1,593 |  10.02× |
| Maximum precision boundary        |             179 |       1,374 |   7.68× |
| Result: 0.0 − 0.0                 |              83 |       1,668 |  20.10× |

> BigDecimal subtraction is consistently 7–11× faster across all tested cases. Trivial operations (subtracting zero or 0.0−0.0) reach 20–29× speedup.

---

### 3. Multiplication (`Decimal`)

**Cases:** 50 | **Iterations:** 500 | **Average Speedup: 3.44×** | **Log date:** 2026-02-11

| Category                             | BigDecimal (ns) | Python (ns) | Speedup |
| ------------------------------------ | --------------: | ----------: | ------: |
| Simple integer (7 × 6)               |             208 |         314 |   1.51× |
| Simple decimal (3.5 × 2.5)           |              90 |         272 |   3.02× |
| Multiply by zero                     |              48 |         264 |   5.50× |
| Multiply by one                      |             100 |         258 |   2.58× |
| Multiply by negative one             |              70 |         258 |   3.69× |
| Precision at limit (28-digit × 28d)  |              96 |         274 |   2.85× |
| High precision repeating             |              94 |         288 |   3.06× |
| Negative × negative                  |              94 |         274 |   2.91× |
| 0 × negative                         |              36 |         258 |   7.17× |
| Large integer (9999999 × 9999999)    |             106 |         260 |   2.45× |
| Large decimal (12345.678 × 98765.43) |             134 |         298 |   2.22× |
| Very large × very small              |              80 |         300 |   3.75× |
| Pi × E                               |              98 |         276 |   2.82× |
| Repeating decimals                   |              86 |         274 |   3.19× |
| Financial (price × quantity)         |              72 |         258 |   3.58× |
| Square operation (x²)                |             102 |         280 |   2.75× |
| Currency conversion                  |             108 |         296 |   2.74× |
| Extreme scale separation             |              68 |         258 |   3.79× |

> BigDecimal multiplication is 2.5–7× faster. Special cases (multiply by zero) reach 5.5–7×. Standard decimal products see a consistent 2.5–3.8× advantage.

---

### 4. Division (`Decimal`)

**Cases:** 64 | **Iterations:** 100 (standard) / 3 (large) | **Average Speedup: 24.62×** | **Log date:** 2026-02-23

Division performance splits into two distinct regimes: standard-precision and large-number division.

#### Standard Precision (28-digit, cases 1–50)

| Category                       | BigDecimal (ns) | Python (ns) | Speedup |
| ------------------------------ | --------------: | ----------: | ------: |
| Simple integer (100 / 4)       |             270 |         320 |   1.19× |
| Simple decimal (10.5 / 2.5)    |             280 |         310 |   1.11× |
| Different scales               |             310 |         360 |   1.16× |
| Division by 1                  |             280 |         320 |   1.14× |
| Positive / negative            |             320 |         290 |   0.91× |
| Negative / negative            |             320 |         300 |   0.94× |
| Large integer / 1              |             270 |         300 |   1.11× |
| Very large / very small        |             270 |         300 |   1.11× |
| Financial (dollars)            |             290 |         290 |   1.00× |
| Precision at limit (28d / 28d) |           1,940 |         470 |   0.24× |
| Repeating pattern division     |           1,290 |         360 |   0.28× |
| PI / E                         |           1,610 |         370 |   0.23× |
| Recurring decimals             |           1,590 |         350 |   0.22× |
| Division with many borrows     |             870 |         360 |   0.41× |
| Division with trailing zeros   |             960 |         360 |   0.38× |
| Precision boundary             |             500 |         300 |   0.60× |
| Wide magnitude range           |             260 |         600 |   2.31× |

> For simple/financial division, BigDecimal is roughly on par (1.0–1.2×). Division involving high-precision operands that require internal rescaling (PI/E, repeating patterns) is 3–5× slower than Python's C-optimized division.

#### Large-Number Division (1,024–262,144 words, cases 51–64)

| Operand Size (words / words) | BigDecimal (ns) | Python (ns) | Speedup |
| ---------------------------- | --------------: | ----------: | ------: |
| 1,024 / 1,024                |           1,480 |      11,280 |   7.62× |
| 2,048 / 2,048                |           2,000 |      25,333 |  12.67× |
| 4,096 / 4,096                |           1,333 |      42,333 |  31.76× |
| 8,192 / 8,192                |           9,000 |      88,666 |   9.85× |
| 16,384 / 16,384              |          10,666 |     170,000 |  15.94× |
| 32,768 / 32,768              |           5,333 |     334,333 |  62.69× |
| 65,536 / 65,536              |           5,666 |     646,666 | 114.13× |
| 262,144 / 262,144            |           2,666 |   2,438,666 | 914.73× |
| 65,536 / 32,768              |           5,333 |     652,666 | 122.38× |
| 65,536 / 16,384              |           2,333 |     289,000 | 123.87× |
| 65,536 / 8,192               |           3,333 |     144,000 |  43.20× |
| 65,536 / 4,096               |           2,000 |      72,333 |  36.17× |
| 65,536 / 2,048               |           1,666 |      38,666 |  23.21× |
| 65,536 / 1,024               |           2,000 |      25,000 |  12.50× |

> For large-number division (≥1,024 words), BigDecimal dramatically outperforms Python: 7–915× faster, with the advantage growing as operand size increases. At 262K words, BigDecimal is **915× faster**.

---

### 5. Square Root

**Cases:** 70 | **Iterations:** 100 | **Precision: 5,000** | **Average Speedup: 4.11×** | **Log date:** 2026-02-25

| Category           | BigDecimal (ns) | Python (ns) | Speedup |
| ------------------ | --------------: | ----------: | ------: |
| sqrt(1)            |         183,310 |   5,480,440 |  29.90× |
| sqrt(4)            |       1,103,900 |   5,160,280 |   4.67× |
| sqrt(9)            |       1,188,090 |   5,152,290 |   4.34× |
| sqrt(2.25)         |       1,172,150 |   5,540,280 |   4.73× |
| sqrt(0.0001)       |         185,140 |   5,503,220 |  29.72× |
| sqrt(0.01)         |         184,960 |   5,480,320 |  29.63× |
| sqrt(2)            |       2,240,510 |   5,544,060 |   2.47× |
| sqrt(3)            |       2,385,330 |   5,641,660 |   2.37× |
| sqrt(PI)           |       2,244,650 |   5,196,300 |   2.31× |
| sqrt(1e20)         |         178,850 |   5,481,070 |  30.65× |
| sqrt(1e-16)        |         178,950 |   5,481,510 |  30.63× |
| 100-word decimal   |       3,217,400 |   5,529,790 |   1.72× |
| 500-word decimal   |       3,647,450 |   5,187,760 |   1.42× |
| 1,000-word decimal |       3,492,190 |   5,188,630 |   1.49× |
| 2,000-word decimal |       3,437,950 |   5,133,390 |   1.49× |
| 3,000-word decimal |       3,579,320 |   5,448,710 |   1.52× |
| 5,000-word decimal |       4,618,130 |   5,130,360 |   1.11× |

> Perfect squares and powers of 10 enjoy 29–31× speedup (fast-path detection). Irrational roots (√2, √3, √π) see 2.3–4.7× speedup. Large multi-word decimals maintain a 1.1–1.7× advantage.

---

### 6. Exp (Exponential)

**12 cases × 6 precision levels** | **Log date:** 2026-02-24

Performance varies significantly with precision. Only non-trivial cases (excluding `exp(0)`) are summarized:

| Precision | Iterations | Avg Speedup (excl. exp(0)) | Best Case      | Worst Case        |
| --------: | ---------: | -------------------------: | -------------- | ----------------- |
|        50 |         50 |                      0.73× | exp(1) 0.99×   | exp(0.0001) 0.33× |
|       100 |         20 |                      0.63× | exp(10) 0.73×  | exp(0.0001) 0.41× |
|       200 |          5 |                      1.08× | exp(0.1) 1.31× | exp(0.0001) 0.59× |
|       500 |          2 |                      1.90× | exp(2) 2.29×   | exp(0.0001) 1.02× |
|     1,000 |          1 |                      2.50× | exp(1) 2.82×   | exp(0.0001) 1.44× |
|     2,000 |          1 |                      5.04× | exp(0.5) 5.52× | exp(0.0001) 3.00× |

Representative detail at **precision = 1,000**:

| Input       | BigDecimal (ns) | Python (ns) | Speedup |
| ----------- | --------------: | ----------: | ------: |
| exp(1)      |       1,779,000 |   5,015,000 |   2.82× |
| exp(-1)     |       2,011,000 |   4,996,000 |   2.48× |
| exp(2)      |       1,714,000 |   4,561,000 |   2.66× |
| exp(0.5)    |       1,832,000 |   4,424,000 |   2.41× |
| exp(10)     |       1,940,000 |   5,132,000 |   2.65× |
| exp(100)    |       1,782,000 |   4,916,000 |   2.76× |
| exp(0.01)   |       1,760,000 |   3,459,000 |   1.97× |
| exp(0.0001) |       1,477,000 |   2,121,000 |   1.44× |

> At low precision (≤100), BigDecimal's exp is 20–40% slower than Python. At precision ≥200, BigDecimal begins to overtake Python, reaching **2.5× at p=1,000** and **5× at p=2,000**. Very small inputs (0.0001) converge faster in Python's implementation.

---

### 7. Ln (Natural Logarithm)

**12 cases × 6 precision levels** | **Log date:** 2026-02-24

The ln function shows highly input-dependent performance. Inputs near 1.0 are much faster; inputs far from 1 (e.g., ln(10), ln(100), ln(0.001)) are slow due to range-reduction overhead.

| Precision | Inputs Near 1 (avg) | Other Inputs (avg) | Notes                                     |
| --------: | ------------------: | -----------------: | ----------------------------------------- |
|        50 |               0.92× |              3.49× | ln(2), ln(0.5) benefit from special paths |
|       100 |               0.71× |              0.20× | Generally slower                          |
|       200 |               1.28× |              0.15× | Near-1 inputs start winning               |
|       500 |               2.68× |              0.09× | Near-1 inputs 2–4× faster                 |
|     1,000 |               4.57× |              0.09× | Near-1 at 3–6×                            |
|     2,000 |              22.32× |              0.22× | Near-1 at 14–31×                          |

Representative detail at **precision = 2,000**:

| Input     | BigDecimal (ns) | Python (ns) | Speedup |
| --------- | --------------: | ----------: | ------: |
| ln(1)     |           1,000 |           0 |     N/A |
| ln(0.99)  |       2,316,000 |  71,057,000 |  30.68× |
| ln(1.01)  |       2,397,000 |  64,525,000 |  26.92× |
| ln(1.1)   |       4,841,000 |  69,773,000 |  14.41× |
| ln(0.9)   |       4,716,000 |  81,471,000 |  17.28× |
| ln(2)     |     236,267,000 |  81,308,000 |   0.34× |
| ln(e)     |     258,946,000 |  80,285,000 |   0.31× |
| ln(10)    |     247,319,000 |  38,340,000 |   0.16× |
| ln(100)   |     250,988,000 |  38,986,000 |   0.16× |
| ln(0.001) |     249,501,000 |  38,874,000 |   0.16× |
| ln(PI)    |     271,086,000 |  82,709,000 |   0.31× |

> **Strong for inputs near 1:** ln(0.99) is 31× faster, ln(1.01) is 27× faster at high precision. **Weak for far-from-1 inputs:** ln(10), ln(100), ln(0.001) are 3–6× slower, because the current range-reduction algorithm requires many iterations. This is a key optimization target.

---

### 8. Nth Root

**10 cases × 6 precision levels** | **Log date:** 2026-02-24

Python's `decimal` module does not have a built-in `root` function; the benchmark compares against a Python-side implementation.

| Precision | Iterations | Avg Speedup | Best Case       | Worst Case             |
| --------: | ---------: | ----------: | --------------- | ---------------------- |
|        50 |         50 |       4.21× | sqrt(2) 9.47×   | 10th_root(1000) 1.48×  |
|       100 |         20 |       4.03× | sqrt(2) 11.90×  | 10th_root(1000) 0.91×  |
|       200 |          5 |       7.08× | sqrt(2) 38.70×  | 10th_root(1000) 1.18×  |
|       500 |          2 |      17.07× | sqrt(2) 101.95× | cbrt(10) 5.59×         |
|     1,000 |          1 |      29.42× | sqrt(2) 321.93× | 10th_root(1000) 5.62×  |
|     2,000 |          1 |      ~100×+ | cbrt(2) 213.59× | 10th_root(1000) 64.49× |

Representative detail at **precision = 50**:

| Operation        | BigDecimal (ns) | Python (ns) | Speedup |
| ---------------- | --------------: | ----------: | ------: |
| sqrt(2) via root |           6,500 |      61,580 |   9.47× |
| cbrt(2)          |          10,460 |      59,360 |   5.67× |
| cbrt(10)         |          16,540 |      21,760 |   1.32× |
| cbrt(PI)         |          12,380 |      63,700 |   5.15× |
| 5th_root(2)      |          10,920 |      62,760 |   5.75× |
| 5th_root(100)    |          14,260 |      19,860 |   1.39× |
| 10th_root(2)     |          11,380 |      46,980 |   4.13× |
| 10th_root(1000)  |          17,480 |      25,860 |   1.48× |
| cbrt(large_dec)  |          11,420 |      64,580 |   5.65× |
| cbrt(0.001)      |          11,660 |      24,140 |   2.07× |

> BigDecimal's nth root is consistently faster at all precision levels tested, with speedup growing dramatically at higher precisions (4× at p=50 → 100×+ at p=2000). The advantage is most pronounced for square and cube roots.

---

### 9. Round (Quantize)

**Cases:** 25 | **Iterations:** 1,000 | **Average Speedup: 105.80×** | **Log date:** 2025-04-11

| Category                              | BigDecimal (ns) | Python (ns) | Speedup |
| ------------------------------------- | --------------: | ----------: | ------: |
| Round down to integer                 |              97 |      10,706 | 110.37× |
| Round down to 1 decimal place         |              93 |      10,203 | 109.71× |
| Round down negative                   |              86 |       9,601 | 111.64× |
| Round up to integer                   |              83 |       9,520 | 114.70× |
| Round up negative                     |              83 |       9,689 | 116.73× |
| Round half up (0.5 → 1)               |              81 |       9,541 | 117.79× |
| Round half up negative (−0.5 → −1)    |              81 |       9,668 | 119.36× |
| Round half even (even digit)          |              85 |      10,037 | 118.08× |
| Round half even (odd digit)           |              82 |       9,654 | 117.73× |
| Round to higher precision (add zeros) |             225 |       9,342 |  41.52× |
| Negative places (round to tens)       |              99 |       9,697 |  97.95× |
| Negative places (round to hundreds)   |              82 |      10,096 | 123.12× |
| Round zero                            |             243 |       9,544 |  39.28× |
| Round very small number               |              49 |       9,597 | 195.86× |
| Round very large number               |             121 |       9,511 |  78.60× |
| Round with carry over (9.9999 → 10)   |              88 |       9,656 | 109.73× |
| Scientific notation value             |             246 |       9,562 |  38.87× |
| Small scientific notation value       |              95 |       9,441 |  99.38× |

> Rounding is BigDecimal's strongest operation: **39–196× faster** across all modes and inputs. The Python `decimal` module's rounding goes through the Python interpreter overhead, while BigDecimal's is a direct compiled operation.

---

### PART II Summary

| Operation        | Avg Speedup | Best Scenario                  | Peak Speedup | Notes                           |
| ---------------- | ----------: | ------------------------------ | -----------: | ------------------------------- |
| Addition         |       2.22× | Standard precision             |        6.34× | Slower at >2,500 digits         |
| Subtraction      |       9.79× | All standard cases             |       28.78× | Consistently fast               |
| Multiplication   |       3.44× | All standard cases             |        7.17× | 2.5–7× across the board         |
| Division (std)   |       ~0.9× | Simple/financial               |        2.31× | Slow on high-precision operands |
| Division (large) |      ~100×+ | 262K words                     |      914.73× | Dramatic scaling advantage      |
| Square Root      |       4.11× | Perfect squares / powers of 10 |       30.65× | p=5000                          |
| Exp              |  0.73–5.04× | High precision (p≥500)         |        5.52× | Slower at p≤100                 |
| Ln (near 1)      |    0.92–22× | High precision, inputs near 1  |       30.68× | Slow for large-magnitude inputs |
| Ln (far from 1)  |  0.02–0.34× | —                              |            — | Key optimization target         |
| Nth Root         |  4.03–100×+ | High precision                 |      321.93× | Scales excellently              |
| Round            |     105.80× | All cases                      |      195.86× | Strongest single operation      |
